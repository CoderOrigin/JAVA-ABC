# Mooc视频学习： 面向对象语言---JAVA

## 1.类的定义

### 1.1 对象、函数
对象 = 属性 + 服务  
数据：属性，状态  
操作：函数  
操作是包含着数据的，把数据和对数据的操作放在一起，数据不对外面公开-->**封装**

### 1.2 this
在成员函数内部可以用this调用其他成员函数

### 1.3 成员变量&本地变量  
本地变量：生存期和作用域都在函数内部，定义在函数内部  
成员变量：生存期是对象的生成期，作用域是类中的成员函数，定义在类中

### 1.4 构造函数
构造函数与类名相同，没有返回类型，  
**重载**：可以有多个构造函数，根据参数不同调用不同的构造函数  
创建对象的时候，先调用构造函数，再初始化成员变量，再进入构造函数内部。

### 1.5 toString()
可以用于任何一个类中，使类的输出变成想要的结果

## 2 对象交互
### 2.1 访问属性
**private** 
私有成员是类的私有，不是对象的私有，可以在类中访问不同对象的私有变量。  
**friendly**
如果前面不加访问属性，就是friendly，在同一个包里可以使用  

### 2.2 类变量
**static** 静态变量，是类的变量，不是对象的变量，可以用”类.“去访问  
同样，函数前加 static，函数是类函数。  
**static函数只能调用static函数，只能访问static变量**

### 2.3  public&编译单元
public 类的定义加上public，该类一定在以该类命名的java文件中，如：   
`public class test{}` 一定在test.java中  
一个 \*\*.java是一个编译单元，里面只能有一个public类，并且和文件名相同

## 3 包
### 3.1
在一个包pac下面的的每个java文件一定有一行`package pac`  
包中类的调用方式：
![package](https://github.com/CoderOrigin/JAVA-Course/blob/firstBranch/image/package.png)

## 4 对象容器
### 4.1 定义
`ArrayList<String> notes = new ArrayList<String>();`  
定义了一个存放String的ArrayList，ArrayList是一种范型类，就是一种容器  
容器的输出带着方括号

### 4.2 对象数组
对象数组的每一个元素都是对象的管理者，而非对象本身  
不像int数组，for-each循环的时候，不能对每个元素赋值，  
对象数组和对象容器都可以在for-each循环中，对对象的成员变量赋值。

### 4.3 set定义
`HashSet<String> notes = new HashSet<String>();`  
HashSet没有重复元素，乱序

### 4.4 Hash(类似python中字典)
`HashMap<Integer, String> hm = new Hashmap<Integer, String>();`  
需要用Integer，int的包裹类型，都是类的名字  
`hm.put(5, "five")` 用于往HashMap的对象中放元素  
重复key进行put，value会覆盖

## 5.继承与多态
### 5.1 定义
`class <子类名字> extends <父类名字> {}`  

### 5.2 父子类的关系
父类成员访问属性|在父类中的含义|在子类中的含义
-|-|-
public|对所有人开放|对所有人开放
protected|只有包内其它类、自己和子类可以访问|只有包内其它类、自己和子类可以访问
缺省|只有包内其它类可以访问|如果子类与父类在同一个包内：只有包内其它类可以访问，否则：相当于private，不能访问
private|只有自己可以访问|不能访问

在构造一个子类的对象时，父类的构造方法也是会被调用的，而且**父类的构造方法在子类的构造方法之前被调用**  
如果我们试图重新定义一个在父类中**已经存在**的成员变量，那么我们是在定义一个与父类的成员变量**完全无关**的变量，
在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们**同名但是互不影响**

### 5.3 super

`super()`在构造函数第一行执行，进入父类的构造函数，可以重载，调用不同的构造函数  
在子类中使用父类的函数，`super.parentsFunction()`  

### 5.4 多态变量和向上造型
JAVA中的变量都是多态变量，比如一个放水果的变量，可以放苹果，也可以重新放橘子，但是不能放打印机  
当把一个子类对象赋给父类变量时，发生了**向上造型*

例子：CD是Item的子类  
```
Item item = new Item();
CD cd = new CD();
item = cd；
CD cc = item; // 不对，编译不通过
CD cc = (CD)item; // 将Item类变量item当做CD类型去给cc变量赋值
```
用括号加类型放在变量前面的操作就叫做**造型**  
造型和（int）转换类型不同的！！一个是转换类型，一个是造型     
造型时，有可能出现**ClassCastException的错误**

### 5.5 绑定
当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。   
绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了，根据变量的**声明类型**决定；  
另一种是晚绑定，即动态绑定。动态绑定在根据变量的**动态类型**决定。    
Java缺省使用动态绑定。

### 5.6 override
**override 覆盖**  
通过父类的对象调用存在覆盖关系的函数时，会调用变量但是所管理的对象的类的函数
